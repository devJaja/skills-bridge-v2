import {
  AppKitAccountButton,
  AppKitButton,
  AppKitConnectButton,
  AppKitNetworkButton
} from "./chunk-URASA46H.js";
import "./chunk-ONC5L43U.js";
import "./chunk-SGQ7MDVU.js";
import "./chunk-L5J6WFXQ.js";
import "./chunk-QUNRGAA4.js";
import "./chunk-LD4QFRZW.js";
import "./chunk-AUIS7EH3.js";
import "./chunk-RTUADX5S.js";
import "./chunk-VVHMJUE2.js";
import "./chunk-OIYDSCA7.js";
import "./chunk-WCCMVFY3.js";
import "./chunk-RRMS6QH4.js";
import "./chunk-DW2FONXD.js";
import "./chunk-HNB35IZC.js";
import "./chunk-SZGQ5TDJ.js";
import "./chunk-N5STL3HK.js";
import "./chunk-N34RNS6E.js";
import "./chunk-ZHIOCUVP.js";
import "./chunk-FRI4ROTB.js";
import "./chunk-NVG4HQLS.js";
import "./chunk-IY3DL25E.js";
import "./chunk-H5RE36KK.js";
import "./chunk-KDDUHIFC.js";
import "./chunk-FS3CSUOV.js";
import "./chunk-HWHNPQTK.js";
import "./chunk-OKUZCUUF.js";
import "./chunk-UL2SI5TU.js";
import "./chunk-ZTSQPW5O.js";
import "./chunk-V3AHLH4T.js";
import "./chunk-6QOWD2HI.js";
import "./chunk-SZCEWMAC.js";
import "./chunk-OHXQ3TIO.js";
import "./chunk-2Y2ZEU7F.js";
import "./chunk-GD73LHOG.js";
import "./chunk-WQRXRS4Z.js";
import {
  AppKit,
  DEFAULT_METHODS,
  PACKAGE_VERSION,
  WcConstantsUtil,
  WcHelpersUtil
} from "./chunk-MQSTXR7J.js";
import "./chunk-4WMCU4XR.js";
import "./chunk-FF44UITQ.js";
import "./chunk-BNM6HIE2.js";
import "./chunk-E4XKPBCR.js";
import {
  ProviderUtil
} from "./chunk-FMG7NSN5.js";
import {
  AccountController,
  AlertController,
  AssetController,
  AssetUtil,
  ChainController,
  ConnectionController,
  ConnectionControllerUtil,
  ConnectorController,
  CoreHelperUtil,
  OptionsController,
  StorageUtil
} from "./chunk-MHKZJGP5.js";
import {
  affectedToPathList,
  createProxy,
  isChanged,
  snapshot,
  subscribe
} from "./chunk-LQH6MSRX.js";
import "./chunk-Q666IA43.js";
import "./chunk-WLSVP57H.js";
import "./chunk-ANJCMEYS.js";
import "./chunk-2YULO2GZ.js";
import "./chunk-WX6CO7XQ.js";
import "./chunk-4BFJFIDA.js";
import "./chunk-6GOASCKB.js";
import "./chunk-7LMDMJQJ.js";
import "./chunk-T6MPIZK5.js";
import "./chunk-V2O2ASAW.js";
import "./chunk-SYLL3SQI.js";
import "./chunk-KASMAJTU.js";
import "./chunk-BCNN2GVT.js";
import "./chunk-IGJGLW5K.js";
import {
  ConstantsUtil
} from "./chunk-AFKSH5YO.js";
import "./chunk-OWINAXAL.js";
import "./chunk-PQS6UORD.js";
import "./chunk-PGPBHMFB.js";
import "./chunk-F3M2F5R6.js";
import "./chunk-5UBV5ZHI.js";
import {
  require_react
} from "./chunk-ASWLBWKD.js";
import {
  __toESM
} from "./chunk-MMN2DTB3.js";

// node_modules/@reown/appkit-controllers/dist/esm/exports/react.js
var import_react2 = __toESM(require_react());

// node_modules/valtio/esm/react.mjs
var import_react = __toESM(require_react(), 1);
var useAffectedDebugValue = (state, affected) => {
  const pathList = (0, import_react.useRef)(void 0);
  (0, import_react.useEffect)(() => {
    pathList.current = affectedToPathList(state, affected, true);
  });
  (0, import_react.useDebugValue)(pathList.current);
};
var condUseAffectedDebugValue = useAffectedDebugValue;
var targetCache = /* @__PURE__ */ new WeakMap();
function useSnapshot(proxyObject, options) {
  const notifyInSync = options == null ? void 0 : options.sync;
  const affected = (0, import_react.useMemo)(
    () => proxyObject && /* @__PURE__ */ new WeakMap(),
    [proxyObject]
  );
  const lastSnapshot = (0, import_react.useRef)(void 0);
  let inRender = true;
  const currSnapshot = (0, import_react.useSyncExternalStore)(
    (0, import_react.useCallback)(
      (callback) => {
        const unsub = subscribe(proxyObject, callback, notifyInSync);
        callback();
        return unsub;
      },
      [proxyObject, notifyInSync]
    ),
    () => {
      const nextSnapshot = snapshot(proxyObject);
      try {
        if (!inRender && lastSnapshot.current && !isChanged(
          lastSnapshot.current,
          nextSnapshot,
          affected,
          /* @__PURE__ */ new WeakMap()
        )) {
          return lastSnapshot.current;
        }
      } catch (e) {
      }
      return nextSnapshot;
    },
    () => snapshot(proxyObject)
  );
  inRender = false;
  (0, import_react.useLayoutEffect)(() => {
    lastSnapshot.current = currSnapshot;
  });
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
    condUseAffectedDebugValue(currSnapshot, affected);
  }
  const proxyCache = (0, import_react.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);
  return createProxy(currSnapshot, affected, proxyCache, targetCache);
}

// node_modules/@reown/appkit-controllers/dist/esm/exports/react.js
function useAppKitNetworkCore() {
  const { activeCaipNetwork } = useSnapshot(ChainController.state);
  return {
    caipNetwork: activeCaipNetwork,
    chainId: activeCaipNetwork?.id,
    caipNetworkId: activeCaipNetwork?.caipNetworkId
  };
}
function useAppKitAccount(options) {
  const state = useSnapshot(ChainController.state);
  const { activeConnectorIds } = useSnapshot(ConnectorController.state);
  const chainNamespace = options?.namespace || state.activeChain;
  if (!chainNamespace) {
    return {
      allAccounts: [],
      address: void 0,
      caipAddress: void 0,
      status: void 0,
      isConnected: false,
      embeddedWalletInfo: void 0
    };
  }
  const chainAccountState = state.chains.get(chainNamespace)?.accountState;
  const authConnector = ConnectorController.getAuthConnector(chainNamespace);
  const activeConnectorId = activeConnectorIds[chainNamespace];
  const connections = ConnectionController.getConnections(chainNamespace);
  const allAccounts = connections.flatMap((connection) => connection.accounts.map(({ address, type, publicKey }) => CoreHelperUtil.createAccount(chainNamespace, address, type || "eoa", publicKey)));
  return {
    allAccounts,
    caipAddress: chainAccountState?.caipAddress,
    address: CoreHelperUtil.getPlainAddress(chainAccountState?.caipAddress),
    isConnected: Boolean(chainAccountState?.caipAddress),
    status: chainAccountState?.status,
    embeddedWalletInfo: authConnector && activeConnectorId === ConstantsUtil.CONNECTOR_ID.AUTH ? {
      user: chainAccountState?.user ? {
        ...chainAccountState.user,
        /*
         * Getting the username from the chain controller works well for social logins,
         * but Farcaster uses a different connection flow and doesn’t emit the username via events.
         * Since the username is stored in local storage before the chain controller updates,
         * it’s safe to use the local storage value here.
         */
        username: StorageUtil.getConnectedSocialUsername()
      } : void 0,
      authProvider: chainAccountState?.socialProvider || "email",
      accountType: chainAccountState?.preferredAccountType,
      isSmartAccountDeployed: Boolean(chainAccountState?.smartAccountDeployed)
    } : void 0
  };
}
function useDisconnect() {
  async function disconnect(props) {
    await ConnectionController.disconnect(props);
  }
  return { disconnect };
}
function useAppKitConnections(namespace) {
  useSnapshot(ConnectionController.state);
  useSnapshot(ConnectorController.state);
  useSnapshot(AssetController.state);
  const { activeChain } = useSnapshot(ChainController.state);
  const { remoteFeatures } = useSnapshot(OptionsController.state);
  const chainNamespace = namespace ?? activeChain;
  const isMultiWalletEnabled = Boolean(remoteFeatures?.multiWallet);
  if (!chainNamespace) {
    throw new Error("No namespace found");
  }
  if (!isMultiWalletEnabled) {
    AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.CONNECTIONS_HOOK, "info");
    return {
      connections: [],
      recentConnections: []
    };
  }
  const { connections, recentConnections } = ConnectionControllerUtil.getConnectionsData(chainNamespace);
  const formatConnection = (0, import_react2.useCallback)((connection) => {
    const connector = ConnectorController.getConnectorById(connection.connectorId);
    const name = ConnectorController.getConnectorName(connector?.name);
    const icon = AssetUtil.getConnectorImage(connector);
    const networkImage = AssetUtil.getNetworkImage(connection.caipNetwork);
    return {
      name,
      icon,
      networkIcon: networkImage,
      ...connection
    };
  }, []);
  return {
    connections: connections.map(formatConnection),
    recentConnections: recentConnections.map(formatConnection)
  };
}
function useAppKitConnection({ namespace, onSuccess, onError }) {
  const { connections, isSwitchingConnection } = useSnapshot(ConnectionController.state);
  const { activeConnectorIds } = useSnapshot(ConnectorController.state);
  const { activeChain } = useSnapshot(ChainController.state);
  const { remoteFeatures } = useSnapshot(OptionsController.state);
  const chainNamespace = namespace ?? activeChain;
  if (!chainNamespace) {
    throw new Error("No namespace found");
  }
  const isMultiWalletEnabled = Boolean(remoteFeatures?.multiWallet);
  if (!isMultiWalletEnabled) {
    AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.CONNECTION_HOOK, "info");
    return {
      connection: void 0,
      isPending: false,
      switchConnection: () => Promise.resolve(void 0),
      deleteConnection: () => ({})
    };
  }
  const connectorId = activeConnectorIds[chainNamespace];
  const connList = connections.get(chainNamespace);
  const connection = connList?.find((c) => c.connectorId.toLowerCase() === connectorId?.toLowerCase());
  const switchConnection = (0, import_react2.useCallback)(async ({ connection: _connection, address }) => {
    try {
      ConnectionController.setIsSwitchingConnection(true);
      await ConnectionController.switchConnection({
        connection: _connection,
        address,
        namespace: chainNamespace,
        onChange({ address: newAddress, namespace: newNamespace, hasSwitchedAccount, hasSwitchedWallet }) {
          onSuccess?.({
            address: newAddress,
            namespace: newNamespace,
            hasSwitchedAccount,
            hasSwitchedWallet,
            hasDeletedWallet: false
          });
        }
      });
    } catch (err) {
      const error = err instanceof Error ? err : new Error("Something went wrong");
      onError?.(error);
    } finally {
      ConnectionController.setIsSwitchingConnection(false);
    }
  }, [chainNamespace, onSuccess, onError]);
  const deleteConnection = (0, import_react2.useCallback)(({ address, connectorId: connectorId2 }) => {
    StorageUtil.deleteAddressFromConnection({ connectorId: connectorId2, address, namespace: chainNamespace });
    ConnectionController.syncStorageConnections();
    onSuccess?.({
      address,
      namespace: chainNamespace,
      hasSwitchedAccount: false,
      hasSwitchedWallet: false,
      hasDeletedWallet: true
    });
  }, [chainNamespace]);
  return {
    connection,
    isPending: isSwitchingConnection,
    switchConnection,
    deleteConnection
  };
}

// node_modules/@reown/appkit/dist/esm/src/library/react/index.js
var import_react3 = __toESM(require_react(), 1);
var modal = void 0;
function getAppKit(appKit) {
  if (appKit) {
    modal = appKit;
  }
}
function useAppKitProvider(chainNamespace) {
  const { providers, providerIds } = useSnapshot(ProviderUtil.state);
  const walletProvider = providers[chainNamespace];
  const walletProviderType = providerIds[chainNamespace];
  return {
    walletProvider,
    walletProviderType
  };
}
function useAppKitTheme() {
  if (!modal) {
    throw new Error('Please call "createAppKit" before using "useAppKitTheme" hook');
  }
  function setThemeMode(themeMode2) {
    if (themeMode2) {
      modal?.setThemeMode(themeMode2);
    }
  }
  function setThemeVariables(themeVariables2) {
    if (themeVariables2) {
      modal?.setThemeVariables(themeVariables2);
    }
  }
  const [themeMode, setInternalThemeMode] = (0, import_react3.useState)(modal.getThemeMode());
  const [themeVariables, setInternalThemeVariables] = (0, import_react3.useState)(modal.getThemeVariables());
  (0, import_react3.useEffect)(() => {
    const unsubscribe = modal?.subscribeTheme((state) => {
      setInternalThemeMode(state.themeMode);
      setInternalThemeVariables(state.themeVariables);
    });
    return () => {
      unsubscribe?.();
    };
  }, []);
  return {
    themeMode,
    themeVariables,
    setThemeMode,
    setThemeVariables
  };
}
function useAppKit() {
  if (!modal) {
    throw new Error('Please call "createAppKit" before using "useAppKit" hook');
  }
  async function open(options) {
    await modal?.open(options);
  }
  async function close() {
    await modal?.close();
  }
  return { open, close };
}
function useWalletInfo(namespace) {
  if (!modal) {
    throw new Error('Please call "createAppKit" before using "useWalletInfo" hook');
  }
  const walletInfo = (0, import_react3.useSyncExternalStore)((callback) => {
    const unsubscribe = modal?.subscribeWalletInfo(callback, namespace);
    return () => unsubscribe?.();
  }, () => modal?.getWalletInfo(namespace), () => modal?.getWalletInfo(namespace));
  return { walletInfo };
}
function useAppKitState() {
  if (!modal) {
    throw new Error('Please call "createAppKit" before using "useAppKitState" hook');
  }
  const [state, setState] = (0, import_react3.useState)({ ...modal.getState(), initialized: false });
  const [remoteFeatures, setRemoteFeatures] = (0, import_react3.useState)(modal.getRemoteFeatures());
  (0, import_react3.useEffect)(() => {
    if (modal) {
      setState({ ...modal.getState() });
      setRemoteFeatures(modal.getRemoteFeatures());
      const unsubscribe = modal?.subscribeState((newState) => {
        setState({ ...newState });
      });
      const unsubscribeRemoteFeatures = modal?.subscribeRemoteFeatures((newState) => {
        setRemoteFeatures(newState);
      });
      return () => {
        unsubscribe?.();
        unsubscribeRemoteFeatures?.();
      };
    }
    return () => null;
  }, []);
  return { ...state, ...remoteFeatures ?? {} };
}
function useAppKitEvents() {
  if (!modal) {
    throw new Error('Please call "createAppKit" before using "useAppKitEvents" hook');
  }
  const [event, setEvents] = (0, import_react3.useState)(modal.getEvent());
  (0, import_react3.useEffect)(() => {
    const unsubscribe = modal?.subscribeEvents((newEvent) => {
      setEvents({ ...newEvent });
    });
    return () => {
      unsubscribe?.();
    };
  }, []);
  return event;
}

// node_modules/@reown/appkit/dist/esm/src/utils/BalanceUtil.js
async function _internalFetchBalance(appKit) {
  if (!appKit) {
    throw new Error("AppKit not initialized when  fetchBalance was called.");
  }
  return await updateBalance(appKit);
}
async function updateBalance(appKit) {
  const address = appKit.getAddress();
  const chainNamespace = appKit.getActiveChainNamespace();
  const chainId = appKit.getCaipNetwork()?.id;
  if (!address || !chainNamespace || !chainId) {
    return {
      data: void 0,
      error: "Not able to retrieve balance",
      isSuccess: false,
      isError: true
    };
  }
  const balance = await appKit.updateNativeBalance(address, chainId, chainNamespace);
  return {
    data: balance,
    error: balance ? null : "No balance found",
    isSuccess: Boolean(balance),
    isError: !balance
  };
}

// node_modules/@reown/appkit/dist/esm/src/library/react/components.js
var import_react4 = __toESM(require_react(), 1);

// node_modules/@lit/react/development/create-component.js
var NODE_MODE = false;
var DEV_MODE = true;
var reservedReactProperties = /* @__PURE__ */ new Set([
  "children",
  "localName",
  "ref",
  "style",
  "className"
]);
var listenedEvents = /* @__PURE__ */ new WeakMap();
var addOrUpdateEventListener = (node, event, listener) => {
  let events = listenedEvents.get(node);
  if (events === void 0) {
    listenedEvents.set(node, events = /* @__PURE__ */ new Map());
  }
  let handler = events.get(event);
  if (listener !== void 0) {
    if (handler === void 0) {
      events.set(event, handler = { handleEvent: listener });
      node.addEventListener(event, handler);
    } else {
      handler.handleEvent = listener;
    }
  } else if (handler !== void 0) {
    events.delete(event);
    node.removeEventListener(event, handler);
  }
};
var setProperty = (node, name, value, old, events) => {
  const event = events?.[name];
  if (event !== void 0) {
    if (value !== old) {
      addOrUpdateEventListener(node, event, value);
    }
    return;
  }
  node[name] = value;
  if ((value === void 0 || value === null) && name in HTMLElement.prototype) {
    node.removeAttribute(name);
  }
};
var createComponent = ({ react: React2, tagName, elementClass, events, displayName }) => {
  const eventProps = new Set(Object.keys(events ?? {}));
  if (DEV_MODE && !NODE_MODE) {
    for (const p of reservedReactProperties) {
      if (p in elementClass.prototype && !(p in HTMLElement.prototype)) {
        console.warn(`${tagName} contains property ${p} which is a React reserved property. It will be used by React and not set on the element.`);
      }
    }
  }
  const ReactComponent = React2.forwardRef((props, ref) => {
    const prevElemPropsRef = React2.useRef(/* @__PURE__ */ new Map());
    const elementRef = React2.useRef(null);
    const reactProps = {};
    const elementProps = {};
    for (const [k, v] of Object.entries(props)) {
      if (reservedReactProperties.has(k)) {
        reactProps[k === "className" ? "class" : k] = v;
        continue;
      }
      if (eventProps.has(k) || k in elementClass.prototype) {
        elementProps[k] = v;
        continue;
      }
      reactProps[k] = v;
    }
    if (!NODE_MODE) {
      React2.useLayoutEffect(() => {
        if (elementRef.current === null) {
          return;
        }
        const newElemProps = /* @__PURE__ */ new Map();
        for (const key in elementProps) {
          setProperty(elementRef.current, key, props[key], prevElemPropsRef.current.get(key), events);
          prevElemPropsRef.current.delete(key);
          newElemProps.set(key, props[key]);
        }
        for (const [key, value] of prevElemPropsRef.current) {
          setProperty(elementRef.current, key, void 0, value, events);
        }
        prevElemPropsRef.current = newElemProps;
      });
      React2.useLayoutEffect(() => {
        elementRef.current?.removeAttribute("defer-hydration");
      }, []);
    }
    if (NODE_MODE) {
      if ((React2.createElement.name === "litPatchedCreateElement" || globalThis.litSsrReactEnabled) && Object.keys(elementProps).length) {
        reactProps["_$litProps$"] = elementProps;
      }
    } else {
      reactProps["suppressHydrationWarning"] = true;
    }
    return React2.createElement(tagName, {
      ...reactProps,
      ref: React2.useCallback((node) => {
        elementRef.current = node;
        if (typeof ref === "function") {
          ref(node);
        } else if (ref !== null) {
          ref.current = node;
        }
      }, [ref])
    });
  });
  ReactComponent.displayName = displayName ?? elementClass.name;
  return ReactComponent;
};

// node_modules/@reown/appkit/dist/esm/src/library/react/components.js
var AppKitButton2 = createComponent({
  tagName: "appkit-button",
  elementClass: AppKitButton,
  react: import_react4.default
});
var AppKitNetworkButton2 = createComponent({
  tagName: "appkit-network-button",
  elementClass: AppKitNetworkButton,
  react: import_react4.default
});
var AppKitConnectButton2 = createComponent({
  tagName: "appkit-connect-button",
  elementClass: AppKitConnectButton,
  react: import_react4.default
});
var AppKitAccountButton2 = createComponent({
  tagName: "appkit-account-button",
  elementClass: AppKitAccountButton,
  react: import_react4.default
});

// node_modules/@reown/appkit/dist/esm/src/library/react/providers.js
var import_react6 = __toESM(require_react(), 1);
var appkit = null;
function memoizeCreateAppKit(config) {
  if (!appkit) {
    appkit = createAppKit(config);
  }
  return appkit;
}
function AppKitProvider({ children, ...props }) {
  memoizeCreateAppKit(props);
  return children;
}

// node_modules/@reown/appkit/dist/esm/exports/react.js
var modal2 = void 0;
function createAppKit(options) {
  if (!modal2) {
    modal2 = new AppKit({
      ...options,
      sdkVersion: CoreHelperUtil.generateSdkVersion(options.adapters ?? [], "react", PACKAGE_VERSION)
    });
    getAppKit(modal2);
  }
  return modal2;
}
function useAppKitNetwork() {
  const { caipNetwork, caipNetworkId, chainId } = useAppKitNetworkCore();
  function switchNetwork(network) {
    modal2?.switchNetwork(network);
  }
  return {
    caipNetwork,
    caipNetworkId,
    chainId,
    switchNetwork
  };
}
function useAppKitBalance() {
  async function fetchBalance() {
    return await _internalFetchBalance(modal2);
  }
  return {
    fetchBalance
  };
}
export {
  AccountController,
  AppKit,
  AppKitAccountButton2 as AppKitAccountButton,
  AppKitButton2 as AppKitButton,
  AppKitConnectButton2 as AppKitConnectButton,
  AppKitNetworkButton2 as AppKitNetworkButton,
  AppKitProvider,
  CoreHelperUtil,
  DEFAULT_METHODS,
  WcConstantsUtil,
  WcHelpersUtil,
  createAppKit,
  getAppKit,
  modal2 as modal,
  useAppKit,
  useAppKitAccount,
  useAppKitBalance,
  useAppKitConnection,
  useAppKitConnections,
  useAppKitEvents,
  useAppKitNetwork,
  useAppKitNetworkCore,
  useAppKitProvider,
  useAppKitState,
  useAppKitTheme,
  useDisconnect,
  useWalletInfo
};
/*! Bundled license information:

@lit/react/development/create-component.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/react/development/index.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=@reown_appkit_react.js.map
